---
layout: post
title: Parslet Intro
categories:
  - ruby
  - parser
---
Tonight I wanted to take some time off from Picky to write about a "Parslet":http://kschiess.github.com/parslet/, a parser construction library by my dear friend "Kaspar Schiess":http://www.absurd.li/.

h2. tl;dr

# Parslet is great.
# @gem install parslet@
# Look at "any of the examples":https://github.com/kschiess/parslet/tree/master/example.
# Try, learn, try again, profit!

h2. What is it?

In Kaspar's words: "A small Ruby library for constructing parsers in the "PEG":http://en.wikipedia.org/wiki/Parsing_expression_grammar (Parsing Expression Grammar) fashion".

A parser is used to transform text data into a semantically meaningful structure by injecting information based on assumptions on the text's structure. For example, @"Hello, Florian!"@ could be parsed into something like: @[sentence: [greeting:hello, separation:comma, name:florian, mark:exclamation]]@.

It's probably best if you just "tried it for yourself":http://kschiess.github.com/parslet/get-started.html.

h2. Are there other parser constructors?

Yes, "Citrus":https://github.com/mjijackson/citrus and "Treetop":http://treetop.rubyforge.org/. But let's be frank here. Parslet eats these for breakfast in terms of ease of use and power, in my humble and almost unbiased opinion. Let me explain why.

h2. Why is it so powerful and easy?

On the main page, Kaspar notes that Parslet is especially easy by "providing the best error reporting" and "not generating reams of code for you to debug".

While both are certainly true, and I do not disagree, but I don't think that that is what makes Parslet so easy or powerful. Surely easi-_er_, but the main reason I love it is that it harnesses the power of Ruby.

The second reason I consider it so great is that it split into a _parser_ and a _transformer_ step, with an intermediate syntax tree that is entirely in Ruby basic atoms, like hashes and arrays.

Why is this cool? To repeat my example, above:
The parser would first parse @"Hello, Florian!"@ into @[sentence: [greeting:hello, separation:comma, name:florian, mark:exclamation]]@ and then, for example,
a @FrenchTransformer@ could be used to transform this into: @Bonjour, Florian!@, the french representation of the english input sentence. So first we get an intermediate semantic expression that we can then transform into something else. And there can be a lot of transformers starting from where the parser ended. Thinking about a @SwedishTransformer@ or an @ItalianTransformer@? Me too. "Optimus Primo, transformate! Ciao!"

Or a chain of transformers that first take the intermediate tree and morph it into a different intermediate tree. The possibilities are endless.

h2. Simple Example

Let's consider a simple example. It is a subpart of the "ERB":http://www.ruby-doc.org/stdlib/libdoc/erb/rdoc/classes/ERB.html "parser and transformer":https://github.com/kschiess/parslet/blob/master/example/erb.rb parser and transformer. ERB is a Ruby templating language by Seki Masatoshi.

We'll look at the whole thing later on.

A simple ERB example would be ERB with a Ruby expression inside:
<pre class="sh_ruby"><code>Hello, my name is<%= name >!</code></pre>

What we get out of the parser is the parts that are text, and the parts that are ruby code.
So with parslet we'd write this:
<pre class="sh_ruby"><code>require 'parslet'

class ErbParser < Parslet::Parser
  rule(:ruby_expression) { (str('%>').absnt? >> any).repeat.as(:ruby) }
  rule(:erb_with_tags) { str('<%=') >> ruby_expression >> str('%>') }
  
  rule(:text) { (str('<%=').absnt? >> any).repeat(1).as(:text) }
  
  rule(:text_with_ruby_expressions) { (text | erb_with_tags).repeat }
  root(:text_with_ruby_expressions)
end

p ErbParser.new.parse("Hello, my name is<%= name %>!")</code></pre>

Just run it :) What you get is a nice semantic tree:
<pre class="sh_ruby"><code>[{:text=>"Hello, my name is"}, {:ruby=>" name "}, {:text=>"!"}]</code></pre>

Let me go through it in steps. I've found out that it is easiest for me to go top-down to define a parser. I hope this suits you too.

We define the starting point, aka the @root@ of the parser with the @root@ method:
<pre class="sh_ruby"><code>root(:text_with_ruby_expressions)</code></pre>
This just says, start with the @rule(:text_with_ruby_expressions)@.

So, now what we know about our simple-ERB language is that it is basically a sequence of text and ruby expressions, repeating. So let's define that:
<pre class="sh_ruby"><code>rule(:text_with_ruby_expressions) { (text | erb_with_tags).repeat }</code></pre>
So either we have text OR (@|@) a ruby expression. And we have that in a repeating fashion. Just as the rule says.

Let's look at the text rule we just used:
<pre class="sh_ruby"><code>rule(:text) { (str('<%=').absnt? >> any).repeat(1).as(:text) }</code></pre>
This means: As long as you don't encounter a ERB start tag (@<%=@), keep taking everything as text. This will stop if it encounters a @<%=@.

At which point Parslet will try to apply the other rule:
<pre class="sh_ruby"><code>rule(:erb_with_tags) { str('<%=') >> ruby_expression >> str('%>') }</code></pre>
This rule just matches anything with erb start @<%=@ and end tags @%>@ around it, with a ruby expression inside.

The ruby expression is simple:
<pre class="sh_ruby"><code>rule(:ruby_expression) { (str('%>').absnt? >> any).repeat.as(:ruby) }</code></pre>
We know this already: As long as you don't encounter an ERB end tag, keep consuming as ruby code.

Got it?

Again, if you run it, you get:
<pre class="sh_ruby"><code>[{:text=>"Hello, my name is"}, {:ruby=>" name "}, {:text=>"!"}]</code></pre>
Niiice.

h2. Goodies that will blow your mind.

Parslet doesn't force you to use a class. It's totally ok to just do this:
<pre class="sh_ruby"><code>include Parslet
parser = (str('Hello') | str('Hi')).as(:greeting)
p parser.parse('Hello')</code></pre>

In Parslet, you can run the parser with a subset of its rules:
<pre class="sh_ruby"><code>p ErbParser.new.erb_with_tags.parse("<%= name %>")</code></pre>
This works because a parser is composed of _Parslets_, or parser atoms, hence the name. @str('hello')@ is one of these atoms, and so is a sequence of atoms, like @str('no') >> str('kidding')@. And you can do a parse directly with one of these, if you want, @(str('Hello') | str('Hi')).parse('Hello')@ as we have seen before.

h2. Conclusion



So we've seen
# that Parslet harnishes Ruby's powers
# 

Hope you learnt something new :)