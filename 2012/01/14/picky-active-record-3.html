<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta content="text/html; charset=utf-8" http-equiv="Content-type" />
    <link href="../../../favico.ico" rel="shortcut icon" />
    <!-- Ugh. -->
    <script src="../../../javascripts/shjs-0.6/sh_main.min.js" type="text/javascript"></script>
    <link href="../../../javascripts/shjs-0.6/css/sh_nedit.min.css" rel="stylesheet" type="text/css" />
    <link href="../../../stylesheets/basic.css" rel="stylesheet" type="text/css" />
    <link href="../../../stylesheets/specific.css" rel="stylesheet" type="text/css" />
    <title>Picky&nbsp;Active&nbsp;Record&nbsp;3</title>
    <script type="text/javascript">
      //<![CDATA[
        var _gaq = _gaq || [];
        _gaq.push(['_setAccount', 'UA-20991642-1']);
        _gaq.push(['_trackPageview']);
        
        (function() {
          var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
          ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
          var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
        })();
      //]]>
    </script>
  </head>
  <body onload='sh_highlightDocument("../../../javascripts/shjs-0.6/lang/", ".min.js");'>
    <ol class="nav">
      <li>
        <a href="./../../../../">home</a>
        •
      </li>
      <li>
        <a href="./../../../">blog</a>
        •
      </li>
      <li>
        <a href="./../../../../picky/">picky</a>
        •
      </li>
      <li>
        <a href="./../../../../phd/">phd</a>
        •
      </li>
      <li>
        <a href="./../../../../phony/">phony</a>
        •
      </li>
      <li>
        <a href="./../../../../view_models/">view models</a>
      </li>
    </ol>
    <div class="post">
      <h1>Picky&nbsp;Active&nbsp;Record&nbsp;3</h1>
      <div class="categories">
        ruby / picky / activerecord
      </div>
      <!-- /  - page.categories.each do |category| -->
      <!-- /    %a{ :href => "/blog/category/#{category}" }= category -->
      <p>This post talks about integrating Picky directly into Rails/ActiveRecord.</p>
      <p>(By the way, greetings from <a href="http://www.cmswire.com/events/item/rails-camp-x-adelaide-2012-013342.php">Rails Camp X Adelaide</a> – come up and say hi if you are here!)</p>
      <p>The last post illustrated a way of writing an active record integration. Still missing is index persistence.</p>
      <p>However, in this post I&#8217;d like to talk about wrapping the last solution up into a nicer bundle.</p>
      <h2>Beautifying the last solution</h2>
      <p>Why? It contains a few advanced Ruby concepts and statements. While I think everybody should know about <code>class &lt;&lt; self</code> and <code>define_method</code>, it can get kind of hard to read compared to a more declarative style that Tire (Elastic Search), Thinking Sphinx (Sphinx), or Sunspot (Solr) offer.</p>
      <p>However: While I like the declarative style in many cases, some libraries hide away too much important code. Many times even code that is hugely important, or does things to your model which you only find out about after reading the library source. After a crash. In production.</p>
      <h2>Goals</h2>
      <p>So what I&#8217;d like is</p>
      <ul>
      	<li>have the important bits be visible and manipulable.</li>
      	<li>hide away boilerplate code that makes code harder to read.</li>
      </ul>
      <p>And maybe most important:</p>
      <ul>
      	<li>use the standard Picky <span class="caps">API</span></li>
      </ul>
      <p>A quick reminder what the basic Picky <span class="caps">API</span> is:</p>
      <pre class="sh_ruby"><code>data = Picky::Index.new :name do&#x000A;  category :name&#x000A;end&#x000A;things = Picky::Search.new data&#x000A;things.search 'something'</code></pre>
      <p>Most other search engine adapters try to elegantify the original <span class="caps">API</span>. This is nice.</p>
      <p>However, having control over both APIs, I believe that using the original (standard) Picky <span class="caps">API</span> creates a pressure on it to stay as elegant as possible and as useable as possible.</p>
      <p>If we hide away the Picky <span class="caps">API</span>, pressure is only excerted on the ActiveRecord/Picky adapter. This also means that people who only use the Picky ActiveRecord <span class="caps">API</span> only come in contact with that one.</p>
      <p>Why is this a problem?
      This is a problem when people want to <em>transcend</em> the AR <span class="caps">API</span> to use for example the separate and specific Picky server. If the APIs look and feel fundamentally different, users will not willingly make this jump.
      In fact, many people then start looking for search engine alternatives. This is a bad thing. Let me put this in bold, because it gets violated so many times:</p>
      <p><strong>The jump from the simple <span class="caps">API</span> to the harder <span class="caps">API</span> should not be noticeable.</strong></p>
      <p>The only way to do this is use a subset of the original <span class="caps">API</span> for the simpler one. However, since Picky is about giving <strong>you</strong> the power, we will not constrict you, but instead make the whole <span class="caps">API</span> accessible.</p>
      <h2>A first draft</h2>
      <p>I am not the biggest fan of the following pattern:</p>
      <pre class="sh_ruby"><code>class Model &lt; ActiveRecord::Base&#x000A;  include Picky::ActiveRecord&#x000A;  &#x000A;  some_method_call_from_the included, module&#x000A;end</code></pre>
      <p>I am not sure why since it&#8217;s perfectly ok Ruby. I believe it is because it usually consists of two lines, and only one really describes what is going on: &#8220;I am using this&#8221; and &#8220;I am using it like this&#8221;.</p>
      <p>With this subgoal in mind, I started drafting the <span class="caps">API</span>. It turned out like this:</p>
      <pre class="sh_ruby"><code>class Model &lt; ActiveRecord::Base&#x000A;  extend(Picky::ActiveRecord.new(:models) do&#x000A;    Picky::Index.new :models do&#x000A;      category :name&#x000A;      category :surname&#x000A;    end&#x000A;  end)&#x000A;end</code></pre>
      <p>Don&#8217;t judge me. It gets better.</p>
      <p>Why do I use so many round parentheses, having declared them unnecessary not so long ago?</p>
      <p>Turns out, <code>extend</code> gobbles up my block. Try running the following code:</p>
      <pre class="sh_ruby"><code>module A; end&#x000A;class B&#x000A;  extend A do&#x000A;  	# ...&#x000A;  end&#x000A;end</code></pre>
      <p>I am unsure what happens here. Looking at the <a href="http://ruby-doc.org/core-1.9.3/Object.html#method-i-extend">CRuby code</a> didn&#8217;t help. Ideas?</p>
      <p>I guess we can all agree that this <span class="caps">API</span> is neither good looking nor elegant. Let&#8217;s try again.</p>
      <h2>A better draft</h2>
      <p>So, teeth grinding, we return back to the standard solution of having a separate include and declarations. However, I&#8217;d like to be able to use the Picky <span class="caps">API</span>.</p>
      <p>This is what I&#8217;ve come up with:</p>
      <pre class="sh_ruby"><code>class Model &lt; ActiveRecord::Base&#x000A;  include Picky::ActiveRecord&#x000A;  &#x000A;  index = Picky::Index.new :models do&#x000A;    category :name&#x000A;    category :surname&#x000A;  end&#x000A;  &#x000A;  search = Picky::Search.new index&#x000A;  &#x000A;  updates_picky index&#x000A;  searches_picky search&#x000A;end</code></pre>
      <p>Let&#8217;s look at the design in detail.</p>
      <h3>In detail</h3>
      <p>First of all, note that no saving of indexes in instance variables is done. You can do it, should you need it, but Picky is not saving anything like <code>@__picky_index</code> for you. Instead, the index and the search are both passed into the a method in which they are captured in a closure.</p>
      <p>Let&#8217;s look at the <span class="caps">API</span> code.</p>
      <p>The line</p>
      <pre class="sh_ruby"><code>include Picky::ActiveRecord</code></pre>
      <p>does two things: First, it includes two other modules, <code>Picky::ActiveRecord::Indexing</code> and <code>Picky::ActiveRecord::Searching</code>, that are concerned with indexing and searching, respectively. It is well imaginable that one doesn&#8217;t want realtime indexing, just searching, or vice versa.</p>
      <pre class="sh_ruby"><code>index = Picky::Index.new :models do&#x000A;  category :name&#x000A;  category :surname&#x000A;end&#x000A;&#x000A;search = Picky::Search.new index</code></pre>
      <p>This is the standard Picky <span class="caps">API</span>. You create an index (definition) and pass it into the search.</p>
      <p>The line</p>
      <pre class="sh_ruby"><code>updates_picky index</code></pre>
      <p>tells this class to automatically update the given index as soon as the <code>after_commit</code> method is called.</p>
      <p>This method can also be called as follows:</p>
      <pre class="sh_ruby"><code>updates_picky :models</code></pre>
      <p>or</p>
      <pre class="sh_ruby"><code>updates_picky</code></pre>
      <p>The first one uses the index called <code>:models</code> and the second one uses <code>model_class.name.tableize</code> to find the model name.</p>
      <p>Finally, the line</p>
      <pre class="sh_ruby"><code>searches_picky search</code></pre>
      <p>installs a <code>Model.search</code> method using the given <code>search</code>.</p>
      <h3>Also of note</h3>
      <p>This <span class="caps">API</span> does not really care where anything is set up. This is well possible:</p>
      <pre class="sh_ruby"><code>class Model &lt; ActiveRecord::Base&#x000A;  include Picky::ActiveRecord&#x000A;end&#x000A;&#x000A;# In e.g. initializers/picky.rb&#x000A;#&#x000A;index = Picky::Index.new :models do&#x000A;  category :name&#x000A;  category :surname&#x000A;end&#x000A;  &#x000A;search = Picky::Search.new index&#x000A;  &#x000A;Model.updates_picky index&#x000A;Model.searches_picky search&#x000A;</code></pre>
      <p>for the case where you&#8217;d like your search code outside the model.</p>
      <p>Also, you can call <code>updates_picky</code> multiple times:</p>
      <pre class="sh_ruby"><code>Model.updates_picky index&#x000A;Model.updates_picky index2&#x000A;Model.updates_picky index3</code></pre>
      <p>Any updates to the model will update each index.</p>
      <h2>Implementation</h2>
      <p>If you&#8217;re interested in the implementation, see <a href="https://github.com/floere/picky/blob/de7784bb15768fba38870601b2ecf59a64009ec7/server/prototypes/integrated_active_record/active_record.rb">the Picky::ActiveRecord module</a> (code at the time of this writing).</p>
      <h2>Finally, you</h2>
      <p>Hope you like the <span class="caps">API</span> design series. The <span class="caps">API</span> is certainly turning out to be simple. Too simple? Who knows.</p>
      <p>Opinions, ideas?</p>
      <p>We still haven&#8217;t looked at index persistence. We save this for another blog post.</p>
      Next
      <a href="/blog/2012/03/01/cocoapods-search-design.html" title="Next post: CocoaPods&amp;nbsp;Search&amp;nbsp;Design">CocoaPods&nbsp;Search&nbsp;Design</a>
      <br />
      Previous
      <a class="previous" href="../../../2012/01/13/picky-active-record-2.html" title="Previous post: Picky&amp;nbsp;Active&amp;nbsp;Record&amp;nbsp;2">Picky&nbsp;Active&nbsp;Record&nbsp;2</a>
      <h2>Comments?</h2>
      <div id="disqus_thread"></div>
      <script type="text/javascript">
        //<![CDATA[
          var disqus_shortname = 'florianhanke';
          var disqus_developer = location.host.match(/\.dev$|^localhost/) ? 1 : 0;
          var disqus_identifier = '/2012/01/14/picky-active-record-3';
          var disqus_url = 'http://florianhanke.com/blog/2012/01/14/picky-active-record-3.html';
          
          /* * * DON'T EDIT BELOW THIS LINE * * */
          (function() {
              var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
              dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
              (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
          })();
        //]]>
      </script>
      <noscript>
        Please enable JavaScript to view the
        <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a>
      </noscript>
    </div>
  </body>
</html>
