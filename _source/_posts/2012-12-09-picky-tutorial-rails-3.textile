---
layout: post
title: Picky&nbsp;Tutorial&#58;&nbsp;Rails&nbsp;3.2
categories:
  - ruby
  - picky
  - rails
---

A note: The main Picky site is now running at "pickyrb.com":http://pickyrb.com

h2. Intro

You'd like to integrate a small Picky server directly in the Rails 3.2 Rails app you are running?

This is the tutorial for you.

To make things a bit more interesting, I want to be able to filter a query with the current user – and also have an AJAX search interface.

h2. Files We Will Touch

# Gemfile
# initializers/picky.rb
# model.rb
# controller.rb
# JavaScript

h2. Gemfile

First of all, we start out by adding picky and the picky-client to the Gemfile, like so:

<pre class="sh_ruby"><code>gem 'picky', '~> 4.9'
gem 'picky-client', '~> 4.9'</code></pre>

The spermy operator @~>@ results in versions @4.9@ up to but not including @5.0@ being used, at which point the API changes which might result in your application not running anymore.

Then do a

<pre class="sh_shell"><code>bundle install</code></pre>

like the latest code preachers tell us to.

h2. initializers/picky.rb

Here's where you define the actual indexes and configure Picky. This is an example where we use a very generic model, imaginatively named "things":

<pre class="sh_ruby"><code># Silence Picky, as an example.
#
Picky.logger = Picky::Loggers::Silent.new

# We create a new index and store it in the constant ThingsIndex.
#
ThingsIndex = Picky::Index.new :things do
  # Our keys are integers.
  #
  key_format :to_i
    
  # Default indexing options.
  # Please see: https://github.com/floere/picky/wiki/Indexing-configuration
  # for more information.
  #
  indexing removes_characters: /[^a-z0-9\s\/\-\_\:\"\&\.]/i,
           stopwords:          /\b(and|the|of|it|in|for)\b/i,
           splits_text_on:     /[\s\/\-\_\:\"\&\/]/,
           rejects_token_if:   lambda { |token| token.size < 2 }
  
  # We should be able to restrict searches to a specific user.
  #
  category :user,
           :partial => Picky::Partial::None.new, 
           :from => :user_ids
  
  # We can search on the titles of the thing.
  #
  # We use postfix partials which means a word can
  # be found if only part has been entered (from the beginning).
  #
  category :title, :partial => Picky::Partial::Postfix.new :from => 1
  
  # We should also be able to search the years that the things have.
  #
  # We want the exact year, so no partial searching.
  #
  category :year,
           :partial => Picky::Partial::None.new
  
end

# ThingsSearch is the search interface
# on the things index.
#
# See https://github.com/floere/picky/wiki/Searching-Configuration
# for some tokenizing options.
#
ThingsSearch = Picky::Search.new ThingsIndex

# We are indexing at the end of this method
# using explicit indexing.
#
# Feel free to run the initial indexing somewhere else.
#
Thing.order('title ASC').each do |thing|
  ThingsIndex.add thing
end</code></pre>

Next up is the model.

h2. model.rb

The model is straightforward: we want to index when saving a model, or delete the model from the index.

<pre class="sh_ruby"><code># After saving or destroying, index.
#
after_save { |thing| ThingsIndex.replace thing }
after_destroy { |thing| ThingsIndex.remove thing.id }
 
# Since we want to index all users that have something to
# do with this thing together with it, we return a string
# of comma separated user ids.
#
def user_ids
  users.inject([]) do |result, user|
    result << user.id
  end.uniq.join ' '
end</code></pre>

If we didn't have the special case with the user ids, we'd only have two lines in the model.

Now, the controller is a bit bigger…

h2. controller.rb

Create a controller action and wire it up in the routes.rb correctly. For example:

<pre class="sh_ruby"><code>resources :things do
  collection { get :search }
end</code></pre>

Now, back to the @search@ action.

<pre class="sh_ruby"><code>def search
  # This line prepends the current user to the query.
  #
  # Since we have indexed the thing's user in the
  # user category, we can prepend a filter to the
  # currently received query.
  #
  # A query like
  #   "one two three"
  # will be transformed into
  #   "user:15 one two three"
  # which will result in things only
  # being found if it is associated to the current user.
  #
  query = "user:#{current_user.id} #{params[:query]}"

  # Perform the search.
  #
  results = ThingsSearch.search query, params[:ids] || 20, params[:offset] || 0
  
  # Render each thing in the results nicely as a partial.
  #
  # (You need to have a "thing" partial file)
  #
  results = results.to_hash
  results.extend Picky::Convenience
  results.populate_with Thing do |thing|
    render_to_string :partial => "thing", :object => thing
  end
  
  # We respond with a nice JSON result.
  #
  respond_to do |format|
    format.html do
      # Homework: Make this a nice HTML results page.
      #
      render :text => "Deal result ids: #{results.ids.to_s}"
    end
    format.json do
      render :text => results.to_json
    end
  end
end</code></pre>

h2. JavaScript

<pre class="sh_js"><code></code></pre>